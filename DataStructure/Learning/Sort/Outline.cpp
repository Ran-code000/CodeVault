//概述：
//一. 内部排序
//1. 冒泡排序
//2. 选择排序 (1)简单选择排序  (2) 堆排序
//3. 插入排序 (1)直接插入排序  (2) 希尔排序
//4. 快速排序
//5. 归并排序
//6. 基数排序
//二. 外部排序

//知识拓展：
// C++ STL（Standard Template Library）提供了多种排序算法，这些算法封装在不同的头文件中
//以下是C++ STL中封装的排序算法及其使用的排序算法类型：

// 1. sort 
// sort(vec.begin(), vec.end());
// sort 是一种非稳定排序算法，通常使用 Introsort 算法
// Introsort 是一种混合排序算法，它结合了快速排序（Quick Sort）、堆排序（Heap Sort）和插入排序（Insertion Sort）
// 退化条件与阈值：
//     当递归深度过深即超过某个阈值（通常为 2 * log(n)），Introsort 从快速排序切换到堆排序。
//     当子数组的大小小于某个阈值（通常是 16 或 32），Introsort 从快速排序切换到插入排序。

// 2. stable_sort 
// stable_sort(vec.begin(), vec.end());
// stable_sort 是一种稳定排序算法，通常使用 归并排序（Merge Sort）或 Timsort
// Timsort 是一种混合排序算法，结合了归并排序和插入排序
// 退化条件与阈值：
//     使用 Timsort 时，当数据部分有序时，算法性能可以接近 O(n)

// 3. partial_sort
// partial_sort(vec.begin(), vec.begin() + k, vec.end()); 
// partial_sort 用于对部分数据进行排序（通常是前 k 个元素）
// 一般使用 堆排序（Heap Sort）或 选择排序（Selection Sort）
// 堆排序：堆排序适用于需要找到前 k 个元素的情况，具有 O(n log k) 的时间复杂度。
// 选择排序：选择排序在 k 很小的情况下表现良好，因为它每次只选择当前未排序部分的最小值放到已排序部分的末尾。
// 退化条件与阈值： 
//    当 k 很小时，堆排序可能退化为选择排序。

// 4. nth_element 
// nth_element 用于部分排序，使得第 n 个元素处于其最终位置，通常使用 快速选择算法（Quickselect）
// 退化条件与阈值：
//     在最差情况下（如每次选择的枢纽都位于极端位置），快速选择的时间复杂度会退化为 O(n^2)。为了避免这种情况，通常使用随机化版本的快速选择或中位数三分法来选择枢纽，从而降低退化的概

// 5. inplace_merge
// 实现与算法
// inplace_merge 用于合并两个已经排序的区间，通常使用 就地归并排序（In-place Merge Sort）
// 退化条件与阈值：
//     对于非常大的数据集，虽然就地归并可以节省空间，但其时间复杂度仍然是 O(n log n)

// 6. partial_sort_copy 
// 将数组的一部分复制到一个新的位置，并保持剩余部分的顺序。
// 一般使用 堆排序（Heap Sort）或 选择排序（Selection Sort）

// 7. sort_copy 
// 会复制整个数组
// sort 是一种非稳定排序算法，通常使用 Introsort 算法
// Introsort 是一种混合排序算法，它结合了快速排序（Quick Sort）、堆排序（Heap Sort）和插入排序（Insertion Sort）

// 8. is_sorted 
// 检查一个范围是否已经排序。
// 不进行排序：只是检查数组是否已经是有序的。

// 9. is_sorted_until 
// 检查一个范围是否已经排序，并返回第一个不满足排序条件的位置。
// 不进行排序：只是检查数组是否已经是有序的。

// 为什么使用这些算法：
// 快速排序：通常具有很好的平均性能（时间复杂度为 O(n log n)），并且的常数因子较小，使得在实际应用中非常快。
// 归并排序：提供了稳定的排序，这对于需要保持元素相对顺序的应用场景非常重要。
// 堆排序：在最坏情况下（比如说快速排序算法中每次选择的枢纽都位于极端位置）仍然具有 O(n log n) 的时间复杂度，这使得在数据量较大时非常有效。
// 插入排序：在数据量小或几乎已经排序时非常快，并且实现简单。

// Q&A
// 1. 为什么 Introsort 会在子数组大小小于 16 或 32 时切换到插入排序

// Introsort 在子数组大小小于 16 或 32 时切换到插入排序，这是通过经验和实际应用中的性能优化得出的结论。
// (1) 算法的常数开销
// 快速排序是一种递归算法，递归的每一层都有一定的常数开销，如递归函数调用、栈操作等。在处理小数组时，这些开销会显得非常明显。
// 插入排序虽然是 O(n^2) 的时间复杂度，但由于其常数因子较小，对于小规模数组来说，插入排序的开销实际上低于快速排序或其他排序算法。
// 根据实际的硬件架构和算法效率研究，经验表明，子数组的大小大约在 10 到 32 的范围内时，插入排序表现优于快速排序。
// 因此 16 或 32 是一个较优的经验值，能平衡递归快速排序的开销与插入排序的性能。

// (2) 缓存效率和分支预测
// 在现代 CPU 架构中，缓存效率和分支预测对排序算法的性能有很大影响。插入排序在处理小数组时具有以下优势：
// 缓存友好：插入排序访问的内存是连续的，能更好地利用 CPU 的缓存，提高数据访问的速度。
// 分支预测：由于插入排序的操作是线性扫描和插入，分支预测命中的概率较高，而快速排序的分支预测效果可能不如插入排序好，尤其是在小规模数组上。
//          16 和 32 是通过实践中分析和测试得出的较好切换点，在这个范围内，插入排序能够比快速排序和其他排序算法更好地利用缓存。

// (3) 经验法则
// 不同的排序算法在不同数据规模和分布上表现不同，现代排序库（如 C++ 的 sort 或 Python 的 Timsort）都是经过多次优化调整得出的。
// 虽然 15、18、19 这些值理论上也可以作为切换点，但大量实际测试表明 16 和 32 能够在不同规模的数据上表现出最佳的平衡效果。
// 16 和 32 是两个典型的值，足以保证在大多数硬件环境下得到较好的性能。


// 2. partial_sort 中堆排序退化为选择排序的原因
// 具体的 k 值范围通常依赖于实际的硬件、编译器优化和输入数据的分布情况。
// 通常，经验法则指出，当 k 小于或等于 10 到 20 的范围时，选择排序的表现往往优于堆排序
// 选择排序的常数开销低
// 堆排序的维护成本高：
//     虽然堆排序的时间复杂度是 O(n log k)，但是在 k 非常小时，维护堆的额外开销（如上移和下移操作）可能会使得堆排序的效率比不上选择排序。


// 3. 如何避免快速排序中每次选择的枢纽都位于极端位置
// 快速排序中每次选择的枢纽都位于极端位置（即出现 O(n^2) 的最差情况），可以通过以下两种方式来选择更合适的枢纽（优化）：
// (1) 随机化版本的快速排序
//     int pivotIndex = l + rand() % (r - l + 1);  // 随机选择枢纽
//     swap(v[pivotIndex], v[r]);  // 将随机选择的枢纽移到末尾
//     int pivot = v[r];
// (2) 使用中位数三分法选择枢纽并进行分区
//     int mid = l + (r - l) / 2;
//     int pivot = medianOfThree(v[l], v[mid], v[r]);
//     int pivotIndex = (v[l] == pivot) ? l : (v[mid] == pivot) ? mid : r;
//     swap(v[pivotIndex], v[r]);  // 将中位数作为枢纽移到末尾


// 4. 数据量很小时使用插入排序还是选择排序
// 当数据量较小时（如少于 16 或 32 个元素），通常使用 插入排序 而不是选择排序。
// 原因如下：
//    插入排序在小规模数据上表现较好，当数组接近有序时，插入排序的比较次数会显著减少。
//    插入排序是稳定的排序算法。
//    插入排序具有较低的常数开销，因为它只需要逐步插入元素到正确的位置。
// 选择排序的劣势：选择排序的时间复杂度总是 O(n^2)，无论数组是否接近有序。
//               每次都要扫描未排序部分来找到最小元素，并将其交换到正确的位置。
// 因此在小规模数据上，选择排序并不如插入排序高效。


// 5. 哪些排序算法是稳定的？
// 稳定的排序算法包括:
// 归并排序（Merge Sort）：稳定，时间复杂度 O(n log n)。
// 冒泡排序（Bubble Sort）：稳定，时间复杂度 O(n^2)。
// 插入排序（Insertion Sort）：稳定，时间复杂度 O(n^2)。
// 计数排序（Counting Sort）：稳定，时间复杂度 O(n + k)，适合整数排序。
// 基数排序（Radix Sort）：稳定，时间复杂度 O(nk)（其中 k 为位数），适合大整数排序。
// 桶排序（Bucket Sort）：在某些情况下稳定，时间复杂度 O(n + k)。

// 非稳定排序包括：
// 快速排序（Quick Sort）：非稳定。
// 堆排序（Heap Sort）：非稳定。
// 选择排序（Selection Sort）：非稳定。


// 6. 时间复杂度为 O(n log n) 的排序算法有哪些？
// 归并排序（Merge Sort）：
//          无论在最优、平均还是最差情况下，时间复杂度都是 O(n log n)，且是稳定的排序算法。
// 堆排序（Heap Sort）：
//          在最优、平均和最差情况下，时间复杂度都是 O(n log n)，但不是稳定的排序算法。
// 快速排序（Quick Sort）：平均时间复杂度为 O(n log n)，但最差情况（如每次选择枢纽都位于极端位置）为 O(n^2)。
//                        通过随机化或三数取中法可以避免最坏情况。但快速排序是非稳定的。
// Timsort：Timsort 是 Python 和 Java 中的排序算法，时间复杂度为 O(n log n)，在处理部分有序数据时表现极佳，是稳定的。


// 7. 堆排序与归并排序的区别与联系
// 算法原理：
// 堆排序：基于堆（通常是最大堆或最小堆）的性质，逐步从无序数组中选出最大或最小元素，构造堆来进行排序。堆排序通过每次从堆顶删除元素并重建堆来实现排序。
// 归并排序：基于分治思想，递归地将数组分成两个子数组，分别排序后再合并。每次合并两个有序数组时，保持排序的稳定性。

// 时间复杂度：
// 堆排序和归并排序的时间复杂度在最优、平均和最差情况下都为 O(n log n)。
// 归并排序有更好的最坏情况表现，而堆排序的实际效率可能比归并排序低，尤其在需要频繁交换的情况下。

// 空间复杂度：
// 堆排序：在原地进行排序，因此其空间复杂度是 O(1)，只需要额外的常数空间。
// 归并排序：需要 O(n) 的辅助空间来存储中间结果，尤其在合并操作中需要额外的临时数组。

// 稳定性：
// 堆排序：不是稳定的，因为元素在堆中交换时，可能打乱相同元素的相对顺序。
// 归并排序：是稳定的，因为在合并阶段，相等的元素保持了它们原来的相对顺序。

// 联系：
// 时间复杂度：堆排序和归并排序的时间复杂度都是 O(n log n)，在数据量较大时都能提供良好的性能。
// 适用场景：两者都适合对大规模数据进行排序，其中归并排序适合稳定性要求较高的场合，而堆排序则更适合需要原地排序的场景。


// 8. 插入排序与选择排序的区别与联系
// 算法原理：
// 插入排序：从第二个元素开始，将其插入到已排序的部分中，找到合适的位置插入。它是通过逐步构建有序序列来完成排序。
// 选择排序：每次从未排序部分中选择最小的元素，将其放置在已排序部分的末尾。选择排序通过每次选择最小或最大元素进行排序。

// 时间复杂度：
// 两者的时间复杂度在最优、平均和最差情况下均为 O(n^2)。
// 但插入排序在部分有序数组上表现更好，在最优情况下（数组已经完全有序），插入排序的时间复杂度可以降为 O(n)。

// 稳定性：
// 插入排序：是稳定的排序算法，因为它在插入时不会改变相同元素的相对顺序。
// 选择排序：不是稳定的排序算法，因为在找到最小元素时，它可能会与后面的元素交换位置，破坏相同元素的相对顺序。

// 交换次数：
// 插入排序：插入排序在需要交换时才进行操作，因此在部分有序的数组上，交换次数很少。
// 选择排序：选择排序每一轮都要进行交换，即使没有必要，因此交换次数相对较多。

// 联系：
// 时间复杂度：两者在平均情况下的时间复杂度都是 O(n^2)，但在小规模数据集上，它们的性能差异可能不大。
// 适用场景：插入排序在小规模、部分有序的数据上表现优越，而选择排序适合在不考虑稳定性、交换次数不多的场合使用。

// 总结
// a.稳定的排序算法：包括归并排序、插入排序、冒泡排序等。
// b.时间复杂度为 O(n log n) 的算法：包括归并排序、堆排序、快速排序、Timsort 等。
// c.堆排序和归并排序的区别：堆排序是原地非稳定排序，归并排序需要额外的空间但稳定。
// d.插入排序和选择排序的区别：插入排序是稳定的，选择排序不是。插入排序在部分有序的数组上表现更好。

// 9. 什么是分支预测？
// 分支预测（Branch Prediction）是现代处理器（CPU）中的一种技术，
// 目的是提高指令执行效率。在程序运行过程中，经常会遇到条件分支（如 if-else 语句或循环），CPU 需要根据条件判断是否执行某个分支。

// 例如，在执行 if (a > b) 这样的代码时，CPU 需要检查条件是否成立，并根据结果跳转到不同的执行路径。
// 这种条件判断会影响流水线（pipeline）的执行，因为如果 CPU 不能预先知道条件的结果，它就无法决定应该继续加载哪条指令。

// 分支预测的作用：为了避免在遇到条件分支时停顿（等待条件的计算结果），现代 CPU 使用“分支预测器”来猜测分支的方向。
//              也就是说，CPU 会尝试提前猜测分支执行的路径，从而继续执行指令。如果预测正确，程序将顺利执行；
//              如果预测错误，CPU 需要清空流水线并重新加载正确的指令，这会产生性能损耗，称为“分支预测失误”或“分支错误”。

// 分支预测的原理和过程：分支预测器根据历史信息和模式来猜测分支的执行路径。
// 它的工作过程可以分为几个步骤：
// 1）分支指令的执行：当 CPU 执行一条分支指令时，它会尝试预测分支将会跳转到哪里（例如：条件成立时跳转到 if 块，条件不成立时跳转到 else 块）。
// 2）历史记录和模式识别：分支预测器通常基于历史模式进行预测。现代 CPU 会记录每个分支之前执行的结果，并根据这些历史数据来做出猜测。
//                      例如，如果一个分支之前 90% 的时间都走了 if 块，那么 CPU 很可能会继续猜测下次也会走同一个路径。
// 3）流水线执行：如果 CPU 猜测的分支方向正确，后续的指令已经准备好并可以直接执行。
//               如果猜测错误，CPU 需要丢弃已经加载的错误指令，重新加载正确的指令，这会导致流水线暂停，降低性能。
// 4）更新历史信息：每次分支执行完毕后，分支预测器会根据实际结果更新它的历史记录，来提高下一次的预测准确性。

// 分支预测器有不同的实现方式，包括：
// 1）静态分支预测：根据简单的规则（如总是预测条件为真或假，或者总是猜测向前跳转）。
// 2）动态分支预测：根据分支的历史行为进行预测，这是现代 CPU 中常见的方式。
    

// 10. 为什么插入排序分支预测命中率高，而快速排序分支预测效果差？
// 在讨论排序算法时，分支预测主要与以下方面有关：
// 1）条件判断：如比较两个元素的大小。
// 2）跳转逻辑：是否根据比较结果进行跳转、交换操作或递归调用。

// （1）插入排序的分支预测优势：
// 1）线性扫描和插入：插入排序的核心操作是逐一遍历数组，并在已排序部分中找到合适的位置插入元素。这意味着其内循环的逻辑是相对简单且线性的。
// 如果元素已经接近有序（如部分有序或完全有序的数组），内循环的条件判断 if (v[j] > key) 大多数时候会产生一个固定的模式（即大部分情况下不需要进行交换），
// 从而使 CPU 的分支预测器很容易预测正确，此时 CPU 可以更高效地执行流水线操作，因为它能正确预测大多数分支指令，减少分支错误的发生。
// 2）少量条件判断：插入排序的逻辑简单，只有一个主要的条件判断 if (v[j] > key)，预测的模式更容易。插入排序通常遍历较短的区间，分支模式更为固定，这进一步提高了预测的命中率。

// （2）快速排序的分支预测劣势：
// 1）递归和复杂条件：快速排序中有更多的复杂分支，尤其是分区操作（partition）中，涉及对枢轴（pivot）元素和其他元素的比较和交换，分区过程中，元素的分布并不均匀，导致分支判断的模式较为复杂。
// 例如，在分区操作中，左右指针分别从数组的两端向中间移动，进行条件判断 if (v[i] <= pivot) 和 if (v[j] > pivot)，
// 这些判断的分布不均匀且随机性较大，分支预测器难以正确预测每次条件的结果。
// 2）递归结构：快速排序的递归结构也会影响分支预测器的性能。每次递归调用都意味着新的条件判断和执行路径，
// 而这些路径可能和之前的递归层次完全不同，因此，预测的历史信息不再适用，导致分支预测失败的概率增大。
// 3）分支失误成本高：快速排序中一旦分支预测失败，尤其是在递归深度较大的情况下，重新加载正确指令的开销会更高。每次分支失误都可能导致较大的流水线停顿和性能损耗。

// 总结
// a.分支预测 是现代 CPU 中用来提高执行效率的一项关键技术，它通过历史信息来猜测程序的执行路径，避免在分支处停顿等待条件判断结果。
// b.插入排序 由于其简单的线性结构和稳定的条件判断模式，分支预测器容易猜测出正确的执行路径，尤其在处理小规模或部分有序数据时，分支预测命中率较高，因此插入排序在这些场合下表现更好。
// c.快速排序 的复杂性导致其分支预测较为困难，尤其是在处理不规则数据和递归调用时，分支预测失误的概率更高。这使得快速排序在小规模数组上可能不如插入排序高效。
// d.这种现象是现代排序算法优化的一部分，尤其在现代硬件环境下，充分利用分支预测可以显著提升算法的实际运行效率。


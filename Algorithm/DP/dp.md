# dp 算法入门

动态规划问题的一般形式就是 ***求最值***

动态规划其实是运筹学的一种 ***最优化方法***，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。

    既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值

    动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

1. 首先，动态规划的 ***穷举*** 有点特别，因为这类问题存在 ***重叠子问题*** ，如果暴力穷举的话效率会极其低下，所以需要 备忘录 或者 DP table 来优化穷举过程，避免不必要的计算。

2. 而且，动态规划问题一定会具备 ***最优子结构***，才能通过子问题的最值得到原问题的最值。

3. 另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的 ***状态转移方程*** 才能正确地穷举。


！！！抓到关键字
以上提到的 ***重叠子问题、最优子结构、状态转移方程*** 就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

    明确状态 -> 定义 dp 数组/函数的含义 -> 明确选择-> 明确 base case


---

下面通过 ***斐波那契数列问题*** 和 ***凑零钱问题*** 来详解动态规划的基本原理

***斐波那契数列问题*** 主要是让你明白什么是 ***重叠子问题（斐波那契数列严格来说不是动态规划问题）***

***凑零钱问题*** 主要举集中于如何列出状态转移方程

---

## 斐波那契数列问题

### 1、暴力递归

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```cpp
long long f(long long n)
{
    if (n == 1 || n == 2)
        return 1;
    return f(n - 1) + f(n - 2);
}
```

---

这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是 ***十分低效*** ，低效在哪里？

首先了解我们的递归过程：

    （1）想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，

    （2）然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。

    （3）最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了

递归算法的时间复杂度怎么计算？ ***子问题个数乘以解决一个子问题需要的时间***

    （1）子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

    （2）解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。

    （3）所以，这个算法的时间复杂度为 O(2 ^ n)，指数级别，爆炸！！！

---

很明显发现了算法低效的原因：

存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质：***重叠子问题***。下面，我们想办法解决这个问题

### 2、带备忘录的递归解法

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个备忘录，每次算出某个子问题的答案后别急着返回，先记到备忘录里再返回；每次遇到一个子问题先去备忘录里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个备忘录，当然你也可以使用哈希表（字典），思想都是一样的。

```cpp

long long helper(vector<long long> &memo, long long x)
{
    if (x == 1 || x == 2)
        return 1;
    if (memo[x] != 0)
        return memo[x];
    memo[x] = helper(memo, x - 1) + helper(memo, x - 2);
    return memo[x];
}
long long f1(long long n)
{
    // 备忘录
    vector<long long> memo(n + 1, 0);
    return helper(memo, n);
}

```

---

递归算法的时间复杂度怎么算？ ***子问题个数乘以解决一个子问题需要的时间***

    子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

    解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

    所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击！！！

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做 ***自顶向下***，动态规划叫做 ***自底向上***。

---

啥叫自顶向下？

    从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫自顶向下。

啥叫自底向上？

    反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算

---

### 3、dp 数组的迭代解法

有了上一步备忘录的启发，我们可以把这个备忘录独立出来成为一张表，就叫做 DP table 吧，在这张表上完成自底向上的推算岂不美哉！

```cpp
long long dp(long long n)
{
    vector<long long> memo(n + 1, 0);
    memo[1] = 1;
    memo[2] = 1;
    for (int i = 3; i <= n; i++)
    {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
    return memo[n];
}
```

实际上，带备忘录的递归解法中的备忘录，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

这里，引出 ***状态转移方程*** 这个名词，实际上就是 ***描述问题结构的数学形式***：

![f](https://img-blog.csdnimg.cn/895620efbc424006b780ec876625f8fd.png)

为啥叫状态转移方程？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。

你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出状态转移方程的重要性，它是解决问题的核心。

很容易发现，其实状态转移方程直接代表着暴力解法。

千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。

这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程， ***当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了*** 。所以，可以进一步优化，把空间复杂度降为 O(1)：

### 4、优化的 dp 数组的迭代解法

```cpp
long long dp1(long long n)
{
    long long prev = 1;
    long long curr = 1;
    for (int i = 3; i <= n; i++)
    {
        long long next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
```

---
有人会问，动态规划的另一个重要特性 ***最优子结构***，怎么没有涉及？因为 ***斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值*** ，以上旨在演示算法设计效率螺旋上升的过程。下面，看第二个例子，凑零钱问题。

---

## 凑零钱问题

题目描述
```txt

给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

// coins 中是可选硬币面值，amount 是目标金额
int coinChange(int[] coins, int amount);

比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币

```

### 1、暴力递归

首先，这个问题是动态规划问题，因为它具有 ***最优子结构*** 的。

要符合最优子结构，子问题间必须 ***互相独立***。

啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

---

比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

---

回到凑零钱问题，为什么说它符合最优子结构呢？

比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案

因为硬币的数量是没有限制的，子问题之间没有相互制约，是互相独立的。

---

那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？

先确定状态，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。

然后确定 dp 函数的定义：当前的目标金额是 n，至少需要 dp[n] 个硬币凑出该金额。

然后确定选择并择优，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少：

---

#### 普通递归方式

```cpp
int coinChange(vector<int> &coins, int amount)
{
    // 定义：要凑出金额 n，至少要 dp(n) 个硬币
    function<int(int)> dp = [&](int n)
    {
        // base case
        if (n == 0)
            return 0;
        if (n < 0)
            return -1;

        // 求最小值，所以初始化为正无穷
        int res = INT_MAX;
        for (int coin : coins)
        {
            int subproblem = dp(n - coin);
            // 子问题无解，跳过
            if (subproblem == -1)
                continue;
            res = min(res, 1 + subproblem);
        }

        return res == INT_MAX ? -1 : res;
    };

    // 我们要求的问题是 dp(amount)
    return dp(amount);
}
```

---
至此，以上算法已经是暴力解法了

![1](https://pic.leetcode-cn.com/e0fd2252775b89649ceb6e867ff0e546ec77621edb566693482c8588a98066b8-file_1583404923188)

---

子问题总数为递归树节点个数，这个比较难看出来，是 O(n ^ k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n ^ k)，指数级别

我们可以看到许多子问题被多次计算。例如，F(1) 被计算了 13 次

---

#### 优化的递归方式

只需要稍加修改，就可以通过备忘录消除子问题

```cpp
int coinChange(vector<int> &coins, int amount)
{
    // 使用 unordered_map 作为备忘录
    unordered_map<int, int> memo;

    function<int(int)> dp = [&](int n) -> int
    {
        // 查备忘录，避免重复计算
        if (memo.count(n))
            return memo[n];

        if (n == 0)
            return 0;
        if (n < 0)
            return -1;

        int res = INT_MAX;
        for (int coin : coins)
        {
            int subproblem = dp(n - coin);
            // 如果子问题无解，跳过
            if (subproblem == -1)
                continue;
            res = min(res, 1 + subproblem);
        }

        // 记入备忘录
        memo[n] = (res != INT_MAX) ? res : -1;
        return memo[n];
    };

    // 调用 dp 函数获取结果
    return dp(amount);
}

```

---

很显然备忘录大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)

---

当然，我们也可以自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的

---

#### 动态规划方式

```cpp
int coinChange(vector<int> &coins, int amount)
{
    // 定义：dp[i] 表示凑出金额 i 所需的最少硬币数
    vector<int> dp(amount + 1, INT_MAX); // 初始化 dp 数组为无穷大
    dp[0] = 0;                           // base case: 凑出 0 金额需要 0 个硬币

    // 遍历所有金额从 1 到 amount
    for (int i = 1; i <= amount; ++i)
    {
        // 遍历所有硬币
        for (int coin : coins)
        {
            // 如果当前金额 i 能够减去当前硬币面额 coin，且 dp[i - coin] != INT_MAX
            if (i - coin >= 0 && dp[i - coin] != INT_MAX)
            {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    // 如果 dp[amount] 仍然是无穷大，说明无法凑出该金额
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}

```

![2](https://pic.leetcode-cn.com/f4fd96a19871ff55282b0fa90e86ee4768a267ee7e5c446fb6b1837bc215fe2e-file_1583404923197)

---

## 测试代码（递归，优化递归和动态规划）

```cpp
#include <iostream>
#include <chrono>
#include <vector>
#include <unistd.h>
using namespace std;

long long f(long long n)
{
    if (n == 1 || n == 2)
        return 1;
    return f(n - 1) + f(n - 2);
}


long long dp(long long n)
{
    vector<long long> memo(n + 1, 0);
    memo[1] = 1;
    memo[2] = 1;
    for (int i = 3; i <= n; i++)
    {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
    return memo[n];
}
long long dp1(long long n)
{
    long long prev = 1;
    long long curr = 1;
    for (int i = 3; i <= n; i++)
    {
        long long next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
void mearsueTime(long long (*func)(long long), long long x)
{
    sleep(1);
    auto start = chrono::high_resolution_clock::now();
    cout << func(x) << endl;
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double, milli> duration = end - start;
    cout << duration.count() << " ms.\n";
}
int main()
{
    //递归
    mearsueTime(f, 40);
    //递归优化
    mearsueTime(f1, 40);
    //动态规划
    mearsueTime(dp, 40);
    //动态规划优化空间
    mearsueTime(dp1, 40);
    return 0;
}

```
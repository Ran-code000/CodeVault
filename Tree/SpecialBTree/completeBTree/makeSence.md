# 玩转完全二叉树

## 概念
      
完全二叉树 (Complete Binary Tree): 
     
除了最后一层，其他层都是满的，且最后一层的节点从左到右填充。

![](https://i-blog.csdnimg.cn/blog_migrate/76622a05f6839fd47c2224ff013b68a4.png)

## 必备知识

     完全二叉树索引特点：（例1）
     （1）如果i = 1，它是根节点
     （2）如果i > 1，它的父节点编号为floor(i / 2)
     （3）如果 2i <=  n，它的左子节点编号为 2i
     （4）如果 2i + 1 <= n，它的右子节点编号为 2i + 1
     
     完全二叉树节点个数和树高之间的关系：（例2）
     （1）高度为 h 的完全二叉树，有 2 ^ h - 1 个结点
          
          等比数列推导 1 + 2 + 2 ^ 2 + 2 ^ 3 + ...... + 2 ^ (h - 1) = 1 * (1 - 2 ^ h) / (1 - 2) 
                                                                   = 2 ^ h - 1

     （2）具有 n 个结点的完全二叉树的高度为 ceil(log2 (n+1))，或者 floor(log2 n) + 1 

          高度为 h - 1 的完全二叉树节点个数最多为 2 ^ (h - 1) - 1
          高度为 h 的完全二叉树节点个数最多为 2 ^ h - 1，最少为 2 ^ (h - 1)

          推导：2 ^ (h - 1) - 1 < n <= 2 ^ h - 1 或 2 ^ (h - 1) <= n < 2 ^ h;
               两边取对数得 ceil(log2 (n+1)) 或 floor(log2 n) + 1

      (3) 第 k 层(从上往下)至多有 2 ^（k - 1）个结点

      (4) 深度和高度

![树的深度和高度](https://i-blog.csdnimg.cn/blog_migrate/d39961f7aed0ec6cc06a81a736b90d1b.png)
     
          如图：树的高度和深度都为4 ( 看层数 )；
          节点 8 的深度为 3；节点 9 的高度为 2；

# 例题代码详解

## 例题组 1 ：（对应知识点 ———— ***完全二叉树***）

### 完全二叉树必备知识点：

     完全二叉树索引特点：（例1）
     （1）如果i = 1，它是根节点
     （2）如果i > 1，它的父节点编号为floor(i / 2)
     （3）如果 2i <=  n，它的左子节点编号为 2i
     （4）如果 2i + 1 <= n，它的右子节点编号为 2i + 1
     
     完全二叉树节点个数和树高之间的关系：（例2）
     （1）高度为 h 的完全二叉树，有 2 ^ h - 1 个结点
          
          等比数列推导 1 + 2 + 2 ^ 2 + 2 ^ 3 + ...... + 2 ^ (h - 1) = 1 * (1 - 2 ^ h) / (1 - 2) 
                                                                   = 2 ^ h - 1

     （2）具有 n 个结点的完全二叉树的高度为 ceil(log2 (n+1))，或者 floor(log2 n) + 1 

          高度为 h - 1 的完全二叉树节点个数最多为 2 ^ (h - 1) - 1
          高度为 h 的完全二叉树节点个数最多为 2 ^ h - 1，最少为 2 ^ (h - 1)

          推导：2 ^ (h - 1) - 1 < n <= 2 ^ h - 1 或 2 ^ (h - 1) <= n < 2 ^ h;
               两边取对数得 ceil(log2 (n+1)) 或 floor(log2 n) + 1

      (3) 第 k 层(从上往下)至多有 2 ^（k - 1）个结点

      (4) 深度和高度

![树的深度和高度](https://i-blog.csdnimg.cn/blog_migrate/d39961f7aed0ec6cc06a81a736b90d1b.png)
     
          如图：树的高度和深度都为4 ( 看层数 )；
          节点 8 的深度为 3；节点 9 的高度为 2；


## 例 1 ：完全二叉树-最近公共祖先（易）

忘了概念的看[1.（3）特殊二叉树](#三特殊二叉树敲重点)

### 题目描述

```txt
完全二叉树-最近公共祖先

如下图，由正整数1，2，3，...组成一棵无限大的完全二叉树。

从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，
比如10到根节点的路径是(10,5,2,1)，由4到根节点的路径是(4,2,1)，从根结点1到根结点的路径上只包含一个结点1，因此路径是(1)。

对于两个结点X和Y,假设它们到根结点的路径分别是(X1,X2,...,1)和(Y1,Y2,...,1)(这里显然有X=X1,Y=Y1)，那么必然存在两个正整数i和j，使得从Xi和Yj开始，Xi=Yj,Xi+1=Yj+1，...，

现在的问题就是，给定X和Y，要求Xi(也就是Yj)。


输入描述
输入的第一行是一个整数T，表示测试用例个数。以下T行，每行对应一个测试用例。
每个测试用例包括两个整数X和Y，这两个整数都不大于1000。

输出描述
对每个测试用例，单独一行输出一个整数Xi。

输入样例
2
10 4
7 13
​
输出样例
2
3
2
3
```

### 实现思路

1. 首先需要明确祖先的定义，忘了见[11.节点的祖先](#2树的相关名词术语)

          我们知道 如果i > 1，

          它的父节点编号为floor(i / 2)，

          它的父亲的父亲的编号为floor(floor(i / 2) / 2)，

          祖父的编号为floor(floor(floor(i / 2) / 2) / 2)，
          
          以此类推......

2. 那我们找两个节点公共祖先即执行上述的循环（循环中判断节点编号大小——>节点编号大的整除 2 ），循环跳出条件为找到相同的祖先(x == y)


### 实现代码

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int find_common_parent(int x, int y)
{
    // 当x和y相同，意味着已经找到了公共父节点
    while (x != y)
    {
        if (x > y)
        {
            x /= 2; // 将x向上移动到父节点
        }
        else
        {
            y /= 2; // 将y向上移动到父节点
        }
    }
    return x; // 此时x == y，返回它们的公共父节点
}

int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int x, y;
        cin >> x >> y;
        cout << find_common_parent(x, y) << endl;
    }
    return 0;
}
```

---

## 例 2 ：完全二叉树的节点个数（易+）

忘了概念的看[1.（3）特殊二叉树](#三特殊二叉树敲重点)

### 题目描述

```txt
完全二叉树的节点个数

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
若最底层为第 h 层，则该层包含 1 ~ 2 ^ h 个节点。


示例 1：
输入：root = [1,2,3,4,5,6]
输出：6

示例 2：
输入：root = []
输出：0

示例 3：
输入：root = [1]
输出：1
 

提示：

树中节点的数目范围是[0, 5 * 10^4]
0 <= Node.val <= 5 * 10^4

题目数据保证输入的树是 完全二叉树
 
进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？
```

### 实现思路


***遍历得到节点数太幼稚了我们不看，我们直接做进阶，尝试一个时间复杂度为 log^2 n 的算法***


由于我们针对的是完全二叉树，忘了见[对应知识点--完全二叉树](#例题组-1-对应知识点--完全二叉树)

          我们知道完全二叉树只有可能最后一层是不满的

          由于
          高度为 h - 1 的完全二叉树节点个数最多为 2 ^ (h - 1) - 1
          高度为 h 的完全二叉树节点个数最多为 2 ^ h - 1，最少为 2 ^ (h - 1)

          那么
          最大层数为 h 的完全二叉树，节点个数一定在 [2 ^ (h - 1), 2 ^ h - 1] 的范围内
          
      1. but 我们注意看题目中对高度的要求有点不同 “若最底层为第 h 层，则该层包含 1 ~ 2 ^ h 个节点”

           所以相应的(h 全部加 1)我们的节点个数范围就应该是 [2 ^ h , 2 ^ (h + 1) - 1]

      2. 现在的问题转换为在范围 [2 ^ h , 2 ^ (h + 1) - 1] 中查找，找到存在节点的最大节点编号（即第几个节点）

      3. 既然是查找，我们不难想到在该范围内通过二分查找的方式得到完全二叉树的节点个数
         
      4. 现在我们就需要找到从哪个节点开始查找，显然我们需要找的是完全二叉树的最底层最左边（节点编号在该层最小）的节点，
         
         因为该节点一定是叶子节点，因此从根节点出发，通过每次访问左子节点，找到查找开始节点并得到了树的高度，
         
         因此至此我们确定了查找范围的实值

      5. 当查找范围有效时，循环执行二分查找

      6. 现在重点来到了查找方法的实现!!!!!!

          （1）我们首先思考：二叉树是什么？
          
               之所以是二叉树而不是三叉树四叉树，就是一个根节点最多有两个子节点

               两个子节点就可以用两种状态表示，两种状态表示就可以用二进制数实现

![tu](https://assets.leetcode-cn.com/solution-static/222/1.png)

          （2）例如我们现在想找节点 12，我们知道 12 的二进制表示为 1100，这个有什么用意呢？

               由于我们此时在第 3 层找，第 3 层节点范围为 [8, 15]，即[1000, 1111]，
               
               显然由于[1000, 1111]最高位相同，无法标志不同的节点，因此我们不考虑最高位
               （即第 i 层对应着 i 位的二进制表示）

               因此 1100 的有效位就只有 100

          （3）我们通过图可以看出来找节点 12 的路径是 右左左，现在我们恍然大悟！！！！！！
               
               我们可以用 1 来表示向右查找， 用 0 来表示向左查找

          （4）那我们应该怎样得到二进制数中特定位的数呢？

               ！！！！用 "1" 逻辑与 取出，为什么这里的 "1" 加了引号，是因为这个不是数字 1 ，而是待得到的数位上数字为 1，
               
               例如我们要得到第三个数位的数，我们的 "1" 就是 0100



### 实现代码

```cpp
int countNodes(TreeNode *root)
{
     //空树显然节点数为 0
     if (root == nullptr)
     {
          return 0;
     }
     //定义层数（！！！！这里层数从 0 开始定义，和我们知识点中的从 1 开始有所不同，注意区分）
     int level = 0;
     //定义 node* 指针指向根节点，用于后续遍历
     TreeNode *node = root;
     //因此从根节点出发，每次访问左子节点，直到遇到叶子节点，找到查找开始节点并得到树高
     while (node->left != nullptr)
     {
          level++;
          node = node->left;
     }
     //通过位运算高效的得到查找范围边界
     //若不好理解位运算可以先理解 low = (int)pow(2,level), high = (int)pow(2, level + 1) - 1;
     int low = 1 << level, high = (1 << (level + 1)) - 1;
     //当查找范围有效时，循环执行二分查找，直到 low == high 时找到一个不存在的点（该点即为存在和不存在的分界点，虚拟编号为 low 或者 high）
     while (low < high)
     {    
          //这一句正常思考逻辑是为 mid = (high + low + 1) / 2，之所以不用这一句是由于如果 high 和 low 都为非常大的数容易造成上溢
          int mid = (high - low + 1) / 2 + low;
          if (exists(root, level, mid))
               low = mid;
          else
               high = mid - 1;
     }
     return low;
}

bool exists(TreeNode *root, int level, int k)
{    
     //用于取数的二进制数，若 level 为 3，则 bits 为 0100，
     int bits = 1 << (level - 1); //将数字 1 左移 level - 1 位得到
     //定义 node* 指针指向根节点，用于后续遍历
     TreeNode *node = root;
     //当 node* 指针指向的节点不为空节点，且没取完该取的所有有效位（即查找路径没到头）时
     while (node != nullptr && bits > 0)
     {
          //判断该数位的值（bits & k）
          //值为 0，向左查找
          if (!(bits & k))
               node = node->left;
          //值为 1，向右查找
          else
               node = node->right;
          //取下一个有效位（即继续按照查找路径查找）
          bits >>= 1; //若在例子中此时变为 0010
     }
     //如果 node != nullptr 为真，就说明循环跳出条件是因为 bits == 0，bits == 0 说明路径走完了，找到了一个不为空的节点，return true;
     //如果 node != nullptr 为假，就说明循环跳出条件是因为 bits == 0，bits == 0 说明路径走完了，但找到了一个为空的节点，return false;
     return node != nullptr;
}
```

---

## 例 3 ：完全二叉树插入器（易）

忘了概念的看[1.（3）特殊二叉树](#三特殊二叉树敲重点)

### 题目描述

```txt
.
完全二叉树插入器

完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一棵完全二叉树中，并在插入后保持其完整。

实现 CBTInserter 类:

CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构；

CBTInserter.insert(int v)  向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值；

CBTInserter.get_root() 将返回树的头节点。
 
```

![tu](https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg)

```txt

示例 1：
输入
["CBTInserter", "insert", "insert", "get_root"]
[[[1, 2]], [3], [4], []]
输出
[null, 1, 2, [1, 2, 3, 4]]

解释
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // 返回 1
cBTInserter.insert(4);  // 返回 2
cBTInserter.get_root(); // 返回 [1, 2, 3, 4]
 

提示：

树中节点数量范围为 [1, 1000] 
0 <= Node.val <= 5000
root 是完全二叉树
0 <= val <= 5000 
每个测试用例最多调用 insert 和 get_root 操作 104 次
```

### 实现思路


***对于一棵完全二叉树而言，其除了最后一层之外都是完全填充的，并且最后一层的节点全部在最左侧***

***也就是说可以添加子节点位置只有最后一层的最左侧的若干个节点，和倒数第二层（如果存在）的最右侧的若干个节点***


由于我们针对的是完全二叉树，忘了见[对应知识点--完全二叉树](#例题组-1-对应知识点--完全二叉树)

          我们这里提供两个方法：
          解法一：用 BFS + 队列
          解法二：用 BFS + 二进制（可以作为例题二用二进制操作树的巩固练习）


      解法一：用 BFS + 队列

      1. 广度优先搜索 ————> 层序遍历，遍历一遍后将所有的叶子节点入队保存

      2. 每次调用 insert(val) 时，我们就创建出一个节点 child，并将它作为队列的队首节点的子节点。
      
      3. 之后，我们需要把 child 加入队尾，并且如果对队首节点已经有两个子节点，我们需要将其从队列中移除

忘了二进制怎么操作的话看，[实现思路6.（2）（3）（4）](#例-2-完全二叉树的节点个数易)

      解法二：用 BFS + 二进制

      1. 首先先得到初始完全二叉树中的节点个数 cnt (本题用了层序遍历，当然可以用例 2 的二分查找优化)

      2. 用 c++ 内置函数得到节点个数 cnt 的二进制从左边数 0 的个数  
   
          __builtin_clz(cnt);
   
      3. 计算二进制数路径有效位（前面已经说明实际的最高位有效位不包括在路径中），即待插入节点的所在的层数

          int highbit = 32 - __builtin_clz(cnt);

          int pathHighbit = highbit - 1;
          
      4. 找插入位置的父节点
          
          在调用 insert(v) 时
          
          （1）我们可以知道它的编号 cnt，那么就可以从高到低循环遍历 cnt 的每一个二进制位（pathHighbit >>= 1）
               直到从右边数第二个数位(条件 pathHighbit > 0001(b))                 
          
          （2）循环逻辑：
               pathHighbit & cnt 如果为 0 就往左子节点移动，为 1 往右子节点移动，这样就可以到达节点需要被插入的位置的父节点

      5. 找插入位置

          现在 pathHighbit >>= 1 得到第一个数位即路径的终点

          我们知道完全二叉树左孩子编号 2x，右孩子编号 2x + 1 ————> 即当编号为奇数时为左孩子，编号为偶数时为右孩子 
          ————> 即 pathHighbit & 1 == 1 时为左孩子，pathHighbit == 0 时为右孩子

### 实现代码

#### 解法一 ： BFS + 队列

```cpp
CBTInserter(TreeNode *root)
{    
     this->root = root;
     //用于层序遍历
     queue<TreeNode *> q;
     //用于储存可以插入数据的叶节点
     queue<TreeNode *> canInsertNodes;
     //从根节点开始层序遍历
     q.push(root);

     while (!q.empty())
     {
          TreeNode *node = q.front();
          q.pop();
          
          //层序遍历
          if (node->left)
               q.push(node->left);
          else if (node->right)
               q.push(node->right);
          //找到了叶节点，将所有找到的叶节点加入到 canInsertNodes 中
          if (!(node->left && node->right)) //node->left == nullptr || node->right == nullptr
               canInsertNodes.push(node);
     }
}

int insert(int val)
{
     TreeNode *child = new TreeNode(val);
     TreeNode *node = candidate.front();
     int ret = node->val;
     //左孩子没有插入节点，就插入到左孩子中
     if (!node->left)
     {
          node->left = child;
     }
     //若右孩子没有插入节点（且左孩已经插入了节点），就插入到右孩子中
     else
     {
          node->right = child;
          //完全二叉树不可能出现左孩子为空，右孩子存在的情况，如果右孩子不为空，那么整个节点必定全部被填满
          //所以将这个填满的节点弹出可以插入节点队列
          candidate.pop();
     }
     //加入新的可插入节点到队尾
     candidate.push(child);
     //按题目要求，返回子节点插入位置的父节点
     return ret;
}

TreeNode *get_root()
{
     return root;
}
```

### 解法二：BFS + 二进制

```cpp
//这个统计节点数的方法可以通过例二的二分查找优化
CBTInserter(TreeNode *root)
{    
     this->root = root;
     //用于层序遍历
     queue<TreeNode *> q;
     //从根节点开始层序遍历
     q.push(root);

     while (!q.empty())
     {
          ++cnt; //自己记得定义一个类的内部变量，这里只展示类的方法实现
          TreeNode *node = q.front();
          q.pop();
          
          //层序遍历
          if (node->left)
               q.push(node->left);
          else if (node->right)
               q.push(node->right);
     }
}
int insert(int val)
{
    int insert(int val) {
    ++cnt;
    TreeNode* child = new TreeNode(val);
    TreeNode* node = root;

    //思路同例 2
    //__builtin_clz(cnt) 是一个 GCC 编译器提供的内建函数，它返回 cnt 的二进制表示中从最左边开始的 0 的个数，
    //31 - __builtin_clz(cnt) 计算的是 cnt 的二进制表示中有效数字（非零）的最高位的索引，这也代表了当前二叉树的层数。假设 cnt 是 15，那么 cnt 的二进制是 1111，__builtin_clz(cnt) 返回 28（因为 cnt 在 32 位整数中从左到右的前 28 位是 0），所以 highbit 会是 31 - 28 = 3，即表示有 3 层
    int highbit = 31 - __builtin_clz(cnt);
    int bits = 1 << (highbit - 1);
    //找插入位置的父节点
    //为什么这里是大于 1 不是像例 2 中一样大于 0？
    //因为此时是插入不是查找，查找时找的是目标节点（已经存在），故路径完整，插入是找目标位置的父节点插入（因为插入前节点目标节点显然还不存在），路径停留在从右边数第二个数位处
    while(node && bits > 1) {
        if (!(cnt & bits)) {
            node = node->left;
        }
        else {
            node = node->right;
        }
        bits >>= 1;
    }
    //找到插入位置的父节点
    if(node){
        //找插入位置
        bits >>= 1;
        //插入为右边第一个数位为 1，说明插入为编号为奇数，由二叉树的性质得右孩子的编号（2x + 1）为奇数
        if (cnt & bits) 
        {
            node->right = child;
        }
        //编号为偶数，由二叉树的性质得左孩子的编号(2x)为偶数
        else 
        {
            node->left = child;
        }
        return node->val;
    }
    return 0;
}
}

TreeNode *get_root()
{
    return root;
}
```